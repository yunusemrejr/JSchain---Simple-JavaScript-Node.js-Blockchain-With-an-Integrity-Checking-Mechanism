//this is a very simple JS blockchain example I made. Learned how to do it from this guy: https://www.youtube.com/watch?v=zVqczFZr124&ab_channel=SimplyExplained

//we imported a JavaScript library named crypto-js with the help of node.js. we simply gave terminal this command: npm install --save crypto-js
//and of course I created a package.json file before commanding to install this lib. Simply buy running "npm init".

//here is the constant named after the hash function SHA256. it imports the sha256 function from our downloaded node module by simply "require"ing it within its module folder.
const SHA256 = require("crypto-js/sha256");

//this is the class where we declare the fundementals of each block in the blockchain. We construct index (blockIndex), timestamp (TMESTMP), data and pHash.
//index will keep track of the block number, timestamp will store the time the block has been created, data will store whatever data we want to store in the block
//and pHash will store the hash of the previous block is there is any (genesis block doesn't have anything before it so won't use pHash for genesis ofc.)
class Block{
    constructor(blockIndex, TMESTMP, data, pHash=''){

        this.blockIndex = blockIndex;
        this.TMESTMP = TMESTMP;
        this.data = data;
        this.pHash = pHash;
        //why does "this.hash" equeals "this.calculateHash" ? Because the hash will be generated by calling our imported hash function. We called it inside our "calculateHash" method.
        this.hash= this.calculateHash;

    }

    calculateHash() {
        //We previously declared a constant that required our hash function. Now we make use of that by returning it and converting
        //our block content into a JavaScript string.
        //NOTE: "JSON.stringify(this.data)" is VERY important for the upcoming integrity check. If we don't stringify it, when we 
        //test whether or not our chain is intact, our method of checking will fail to detect the change of data object.
       return SHA256(this.blockIndex + this.pHash + this.TMESTMP+ JSON.stringify(this.data)).toString();
    }
}
 //this is our second class. Our constructor creates a chain element which equals to our special module for creating our first ever block: Genesis.

class MakeBlockchain{
    constructor(){
        this.chain = [this.createGenesisBlock()];
    
        
    }

    createGenesisBlock() {
        //here are our details of the genesis block. This is our blockchain's beginning point. All the new blocks will be added to this.
        //our index: 0, time: 3/31/2022, data: Genesis block, previous hash = 0 / none (there is no previous block).
     return new Block(0, "3/31/2022", "Genesis block", "0");
    }
    
    //this method helps us find the latest block on our blockchain.
    getLatestBlock(){
     return this.chain[this.chain.length -1];
    }
    
    //this method makes it possible to add a new block to our blockchain. How?
    //Well, here are the steps: First we declare that our new block's previous hash equals to the hash of the block before it. Remember "length -1".
    // Second step: we call our calculateHash method to run our imported hashing module for this spesific block's creation.
    //Third and last step is to add our block to the chain by commanding "push(newBlock)".
    addBlock(newBlock) {
        newBlock.pHash = this.getLatestBlock().hash;
        newBlock.hash = newBlock.calculateHash();
        this.chain.push(newBlock);

    }
    
    //this next method is essential for our blockchain's sequrity and integrity. It's name explains itself.
   
    

    isChainValid() {
            //we create a for loop that checks if the blocks have mathing hashes. Our for loop runs until we reach the last block on the chain.

        for(let i = 1; i < this.chain.length; i++){
             //the constant "currentBlock" is found when the for loop reaches the last block on the chain. The variable "i" will not increase it's
    //value anymore so that the "length" of the chain has been reached.
            const currentBlock = this.chain[i];
            //the constant "previousBlock" is calculated by subtracting "1" from the final length of the chain. Because in order for there to be
    //a "previous" there must be more than 1 block.
            const previousBlock = this.chain[i-1];
            // in this if statement we check whether the hash of our current block is original and not tempered.
            if(currentBlock.hash !== currentBlock.calculateHash()) {
                            //if we detect a change, we return "false". (boolean algebra).

                return false;
            }
            // in this if statement we check whether the hash of our previous block is still the same in our current block and not tempered.

            if(currentBlock.pHash !== previousBlock.hash){

//if we detect a change, we return "false". (boolean algebra).

                return false;
            }
            
        }
        // this is our "else" statement. We return "true" because neither of the above if statements returned false.
        return true;
    }
}

//here we start the action. Remember our genesis block? Here we bring it to life. We run the creation method putting it inside
// a variable (which will be our blockchain's name. In my case I named it JSchain).
let JSchain = new MakeBlockchain();

//now that we have our genesis block, why not add some extra blocks to it? We want a chain right?
//as you can see our first new block has an index of 1. (Genesis block index is zero). Remember our time and data variables? They are in use now!
JSchain.addBlock(new Block(1, "3/31/2022", {somethingValue: 2}));
JSchain.addBlock(new Block(2, "3/31/2022", {somethingValue: 11}));

//is our BlockChain valid? (checks if tempered with or not and returns a boolean value. In our case its true/false).
console.log('is BC valid as of now? ' + JSchain.isChainValid());

//let's try to mess around with our chain to check if it is really protected agains tempering. 
//here we try to mess with it by saying chain 1 has a value of 1003 from now on because I want it to be. It should not accept it.
JSchain.chain[1].data = {somethingValue: 1003};
//here we try a different attack. We go and say well, from now on the hash of the chain number one will be recalculated. It should also not accept it and say "false".
JSchain.chain[1].hash = JSchain.chain[1].calculateHash();

//our chain was valid before we attempted to change it. Is it still that way after our 2 different attacks? It should be.
console.log('is BC still valid after our tempering attempt? ' + JSchain.isChainValid());

//let's output our chain as a whole so that we can see it better outside of the code.
//details: we stringify, and set spaces to "2". Spaces are for reading the output easier, not something that determines the  content of output data other than adding spaces.
//also without "null", the output will be compressed into a few lines. 
console.log(JSON.stringify(JSchain, null, 2));


//NOTE: The output will CONTAIN the incorrect data value for chain 1. Why? We returned "false" in order to declare that the chain is
//not correct anymore BUT we didn't stop it from changing the output result on our terminal which means it will still print out the
//tempered result but will never validate it as "true".


//-Yunus Emre Vurgun

